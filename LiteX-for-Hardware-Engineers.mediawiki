This is an introduction to LiteX written by and for hardware engineers who have experience designing FPGAs using Verilog and Vivado. 

Experienced Python engineers can skip this and [https://github.com/m-labs/migen read the source code] for documentation.

__TOC__

==What is LiteX?==
LiteX is a Python "front-end" that generates Verilog netlists, and drives proprietary build "back-ends", such as Vivado or ISE, to create bitstreams ("gateware") for FPGAs.

LiteX is relies on a Python toolbox called [https://github.com/m-labs/migen Migen]. In addition to a build environment, it provides a set of IP blocks, most of them written and maintained by [https://github.com/enjoy-digital?tab=repositories Enjoy-Digital]. Some of the IP blocks include a DDR2/3 MIG equivalent, various softcore CPUs (lm32, or1k, RISCV), Ethernet controller, HDMI input/output, Wishbone routing fabrics, streams, and PCI express.

LiteX naively supports Linux/x86. It requires Python3.5 or later. You'll need to manually download, install, and provision your back-end tools (e.g. Vivado/ISE), and you'll also need to install a gcc cross-compiler to any softcore CPU you plan to use in your designs. Details later.

Here's the design flow in a nutshell:

# Describe your design in Python using the migen toolbox and LiteX IP by customizing a "Module" object (typically by subclassing SoCSDRAM, which is a subclass of SoCCore which subclasses the base Module class)
# Describe your build environment by customizing a "Platform" object (typically by subclassing the XilinxPlatform class which itself sublcasses the GenericPlatform base class)
# Run a function which passes your "platform" object to a Builder object, and invokes the build() method which:
## Creates a "top.v" file: a single, flat verilog netlist of your entire design modulo a few exceptions to be noted later.
## Creates a "top.xdc" file: constraints that locate pins, defines clocks, and eliminates false paths
## If a CPU is configured, generates and builds a BIOS binary to be compiled into the design
## If a toolchain is configured, creates a "top.tcl" file which drives the proprietary synth/place/route/bitgen "backend" toolchain
## Attempts to run the proprietary back-end tool (Vivado will be assumed for this doc, but ISE is also supported)
# Run "make" in the "firmware" directory, which builds your firmware binary (firmware.bin).
# Upload top.bit to the FPGA -- typically over JTAG via openOCD
# Upload firmware.bin to the FPGA -- typically via UART or Ethernet, using the "flterm" host-native application and the "serialboot" command
# Interact with your firmware's REPL loop using flterm
# If you designed a "litescope" into your design (an ILA like Chipscope), configure triggers and download traces using an analyzer script, which relies on a helper program called litex_server. Debugging occurs either through a supplementary UART or Ethernet that must be present in the hardware (either designed in or test leads connected to a header).
# Find bugs & go back to step 1!

LiteX-buildenv attempts to automate steps 3 and onwards. However, I don't use the master script, it's a bit too brittle yet for reliable development, so I tend to run each of the major steps one command at a time.

==Editors and Environments==
It's extremely helpful to use a very featureful Python editor when coding with LiteX/migen. Just trying to code in a basic text editor will drive you nuts. I was introduced to [https://www.jetbrains.com/pycharm/ PyCharm], and I would strongly recommend it if you don't already have a preferred editor. In particular you want to be able to "push" into object declarations by control-clicking on the name and method name autocompletion is extremely helpful when groping around for signal names. 

Furthermore, Python has several key limitations, a major one being package management. Namely, it's not a native feature of the language. Just running setup.py on various eggs will toss all your packages into your system dist-packages directory, which can break other dependencies in your Linux system. If you ask five Python developers how to deal with this, you'll get five different answers. Litex-buildenv I think tries to use Conda to get around this. Just be aware there's some weird stuff going on here that's totally obvious to the package maintainer and if you don't match your assumptions to theirs you'll be blindsided by a problem down the road.

[[https://raw.githubusercontent.com/wiki/timvideos/litex-buildenv/warningSmall.png]] '''Warning:'''
Python3 is inherently nondeterministic. This is a "security feature" which causes, among other things, dictionaries and hash iterators to be visited in a different order every time a script is run. '''This means your verilog netlist, register space addressing, and so forth will change with every run.''' Some think this is a feature, I think this is a bug. I work around this by setting the PYTHONHASHEEED variable to a fixed value, and checking the setting within the Python script. It's not possible to change or set the variable once the program is started. You can only check it.

== What is Migen?==
Migen is the Python toolbox that's used to create a description of your hardware design. It abuses the Python's object-oriented class and method system to create a design tree embodied as a single mega-object. 

For design description, the base class is a "Module". It has five key attributes used to organize the elements that describe any hardware design:
* Comb
* Sync
* Submodules
* Specials
* ClockDomains

Each of these attributes is a list, and a design is described by appending an element to the appropriate list. Once all the lists have been populated, the submodules are collected and then finalized into a single, huge verilog netlist. 

The elements that go into a design description are numerous, but the most common one you'll encounter is Signal(), followed distantly by ClockDomain() and Instance(). 

A Signal(), as its name implies, is a named net. By default, a Signal() has a bit width of 1. An n-bit signal is created by Signal(n). Groups of Signals() can be bundled together in Records() and Streams(), more on that later. A Signal() has no inherent direction, clock domain, or meaning. It picks this all up based on how you use it: which attribute of the Module class you've assigned it to, and so forth. 

So let's look at what each of these attributes are, one at a time.

===Comb===
The comb attribute is a list of "combinational" logic operations. The verilog equivalent is everything that occurs outside an always @(posedge) block, e.g. all your assign statements. Since comb is a list, you append operations onto the list using Python list syntax. "self" is a shortcut to your module object, and ".comb" is how you reference the "comb" attribute:

 <nowiki>
 foo = Signal()  # these are all one-bit wide by default
 bar = Signal()
 baz = Signal()
 mumble = Signal()
 self.comb += [
   foo.eq(bar),
   baz.eq(foo & mumble),  # trailing commas at the end of a list are OK in python
 ]</nowiki>

This is the verilog equivalent of:
 <nowiki>
 wire foo;
 wire bar;
 wire baz;
 wire mumble;
 assign foo = bar;
 assign baz = foo & mumble;</nowiki>

You'll notice that there's no "=" operator -- assignment (and thus declaration of which signal in the source and sink) is done by invoking .eq() on the sink and putting the source as the argument for a signal. However, most arithmetic operations are available between Signals, e.g. ~ is invert, & is and, | is or, + is add, * is multiply. I think there's also divide and I have no idea about signed types. 

===Sync===
The Sync attribute is the list of synchronous operations. Items added to this list will generally infer a clocked register. 

"But to what clock domain?" I hear you ask. Migen starts with a single, default clock domain called "sys". Its frequency is defined by passing a mandatory "clk_freq" argument to the SoCSDRAM base class, and it's up to you to actually hook up a clock generator that is at the right frequency. 

You can also specify which clock domain you want registers to go to by adding a modifier to the sync attribute. The migen methodology prescribes *not* assigning a clock domain until a module is instantiated. So if a sub-module's design can be implemented in a single, synchronous domain, just use the generic "sync" attribute. If the sub-module requires two clock domains, it's actually recommended to make up a "descriptive" name for the module, such as "write" and "read" clock domains for a FIFO. Then, when the modules are created, the all the clocks can be renamed to be consistent with the instantiating-module level clock names using a function called ClockDomainsRenamer(). 

Clear as mud? Some examples will help. 

 <nowiki>
 foo = Signal()
 bar = Signal()
 bar_r = Signal()
 self.sync += [
    bar_r.eq(bar),
    foo.eq(bar & ~bar_r),
 ]</nowiki>

This is the verilog equivalent of
 <nowiki>
 wire bar;
 reg foo = 1'd0;  // yes, the autogen code will use decimal constants
 reg bar_r = 1'd0;
 always(@posdege sys_clk) begin
    bar_r <= bar;
    foo <= bar & bar_r;
 end</nowiki>

Again, sys_clk is implicit because we used a "naked" self.sync. And, note that the "zero" initializer of every register is part of the migen spec (so if you forget to hook up an input to an output, you get zeros injected at the break and no warnings or errors thrown by the verilog compiler).

If you wanted to do two clock domains, you might do something like this:
 <nowiki>
 class Baz(Module):
   def __init__(self):
     foo = Signal()
     bar_r = Signal()
     bar_w = Signal()
     self.sync.read += bar_r.eq(foo)   # when adding just one item to the list, you can use +=
     self.sync.write += bar_w.eq(foo)</nowiki>

This is the verilog equivalent of
 <nowiki>
   wire foo;
   reg bar_r = 1'd0;
   reg bar_w = 1'd0;
   always(@posedge read_clk) begin
     bar_r <= foo;
   end
   always(@posedge write_clk) begin
     bar_w <= foo;
   end</nowiki>

Easy enough, but where does read_clk and write_clk come from? Notice how I encapsulated the Python in a module called Baz(). To assign them in an upper level function, do this:

 <nowiki>
 mybaz = Baz()
 mybaz = ClockDomainsRenamer( {"write" : "sys", "read" : "pix"} )(mybaz)
 self.submodules += mybaz  # I'll describe why this is important later, but it's IMPORTANT</nowiki>

What's happened here is the the "write" domain of this instance of Baz() got assigned to the (default) sys_clk domain, and the "read" domain got assigned to a pix_clk domain (which presumably, you've created in the ClockDomains attribute, more on how to do that later). As you can see here, the ClockDomainsRenamer lets us go from the local names of the function to the instance names used by the actual design, based on a Python dictionary that has the format {"submodule1_clock" : "actual1_clock", "submodule2_clock" : "actual2_clock", ...}. 

The final re-assignment of mybaz to mybaz isn't mandatory, but since you never want to use the original instance of it, it's helpful to discard any possibility of confusing yourself with the old an new versions by re-assigning the modified object to its original name. 

There's one other trick for ClockDomainsRenamer. Quite often you're looking to actually rename the default "sys" clock to something else, because most modules are written just adding items to the base "sync" domain (and hence the default sys clock domain) This leads to this shortcut:

 <nowiki>
 myfoo = Foo()
 myfoo = ClockDomainsRenamer("pix")(myfoo)
 self.submodules += myfoo</nowiki>

The one argument is automatically expanded by the ClockDomainsRenamer to the dictionary {"sys":"lone_argument_clk"}.

==Submodules==
Noticed how above, I was particular to include a line "self.submodules += myfoo" or similar at the end of every example? This has to do with the submodules attribute.

Designs can be hierarchical in migen. That's a good thing, but you have to tell migen about the submodules, or else they don't do anything. You tell migen about a submodule -- and thus include it for flattening and netlisting -- by adding it to the submodule attribute. Forgetting to do so will silently fail, throwing no errors and leaving you wondering why the submodule you thought you included is outputting nothing but 0.

Here's a simple example:
 
 <nowiki>
 myfoo = Foo()
 myfoo = ClockDomainsRenamer("pix")(myfoo)
 self.submodules += myfoo</nowiki>

versus

 <nowiki>
 myfoo = Foo()
 myfoo = ClockDomainsRenamer("pix")(myfoo)</nowiki>

What's the difference? In the first one, we remembered to add our module to the submodules list. In the second one, we created the submodule, did something to it, but didn't add it to the submodules list. 

The second one is perfectly valid Python syntax; it will compile and run, and the verilog generated will throw no errors, but if you look at the netlist, the entire contents of the "myfoo" instance is missing from the generated netlist. 

In other words, it's extremely easy to forget to add something to the submodules list, and forgetting to do so means the submodule is never flattened during the build process and thus never sent to the code generator. And because migen initializes all registers to 0, the absence of the module will result in perfectly valid verilog being generated that throws no errors. 

So I try to include that line in every example, even the short ones, to save you the headache and trouble. 

One other confusing bit about adding something to submodules is that later references go through self. Easier to see code than explain:

 <nowiki>
 self.submodules.myfoo += Foo()
 self.comb += self.myfoo.subsignal.eq(othersignal)</nowiki>

In the example above, you added Foo() to submodules.myfoo, but later on you /reference/ it through self.myfoo. 

===Specials===
To be written -- don't forget to include how to instantiate verilog modules here

===ClockDomains===
To be written

==Physical Constraints==
===Pin Constraints===
To be written -- how to add pin location constraints to your project.
===Timing Constraints===
To be written -- how to add additional timing constraints to your project.

==Timing Reports & Schematics==
To be written -- how to use Vivado to view timing reports and schematics. 

==Softcores==
===CSRs: Config and Status Registers===
To be written -- how to create CSRs, access bits, get them into your clock domain, and prevent false timing paths

===BaseSoC and Clockgen===
To be written -- simple walk-through of the basic stuff needed to implement an lm32 CPU with a clock generator

==Design Patterns==
A collection of design patterns enabled by the migen toolbox.

===Timing Delays===
Timing delays -- inserting pipeline registers to equalize delays between control and data paths -- is a common task. There's a few ways to do it in Migen. Here's some examples.

The simplest way to create a delay is to make it manually:

 <nowiki>
 sig = Signal()
 sig1 = Signal()
 sig2 = Signal()
 sig3 = Signal()
 self.sync += [
    sig3.eq(sig2), # three clock cycles delay
    sig2.eq(sig1),
    sig1.eq(sig),
 ]
 </nowiki>

This can get cumbersome for busses. Here's an example of creating a record that defines a bus, and then using a parameterizeable function that builds the delay pipe with a for loop.

 <nowiki>
 rgb_layout = [  # define the bus layout as a record
    ("r", 8),
    ("g", 8),
    ("b", 8)
 ] 
 #
 # mediawiki "nowiki" format on github eats blank lines, so I'll put empty comments on empty lines to work around this bug
 #
 class TimingDelayRGB(Module):
    def __init__(self, latency):
        self.sink = stream.Endpoint(rgb_layout)    # "inputs"
        self.source = stream.Endpoint(rgb_layout)  # "outputs"
        #  #  #
        for name in list_signals(rgb_layout):
            s = getattr(self.sink, name)
            for i in range(latency):
                next_s = Signal(len(s))
                self.sync += next_s.eq(s)          # self.sync means this module by default is using "sys" clock
                s = next_s
            self.comb += getattr(self.source, name).eq(s)
  #
  #
 class MyModule(Module):
   def __init__(self):
     timing_rgb_delay = TimingDelayRGB(4) 
     timing_rgb_delay = ClockDomainsRenamer("pix_o")(timing_rgb_delay)  # remap the default "sys" clock to local "pix_o" domain
     self.submodules += timing_rgb_delay                   # if you forget this line, the timing delay won't be generated in the verilog netlist
     #
     self.hdmi_out0_rgb = hdmi_out0_rgb = stream.Endpoint(rgb_layout) 
     self.hdmi_out0_rgb_d = hdmi_out0_rgb_d = stream.Endpoint(rgb_layout) 
     self.comb += [
            hdmi_out0_rgb.b.eq(core_source_data_d[0:8]),   # wire up the input record
            hdmi_out0_rgb.g.eq(core_source_data_d[8:16]),
            hdmi_out0_rgb.r.eq(core_source_data_d[16:24]),
            hdmi_out0_rgb.valid.eq(core_source_valid_d),
            #
            timing_rgb_delay.sink.eq(hdmi_out0_rgb),       # wire the input record to the timingdelay element
            #
            hdmi_out0_rgb_d.eq(timing_rgb_delay.source)    # hdmi_out0_rgb_d is 4 cycles delayed from hdmi_out0_rgb
     ]
</nowiki>

So this uses a "record" with r,g,b fields, takes a latency parameter, and automatically iterates through the latency depth and creates a set of daisy-chained registers.

Note that in the TimingDelayRGB() module, we're iterating through and using the same variable name, "next_s" over and over again. It would seem that this wouldn't make a delay, but rather a whole bunch of wires all tied to the same signal. However, next_s is just a temporary variable name, and the Signal() '''object''' assigned to it is always unique because every call to Signal() creates a brand new Signal() object.

Breaking it down step by step:

 <nowiki>next_s = Signal(len(s))</nowiki>

Is creating a new Signal() object, with a globally unique ID, and temporarily binding it to next_s. 

 <nowiki>self.sync += next_s.eq(s)</nowiki>

This adds the next_s Signal to the sync list. What happens is migen automatically sees that the object referenced by next_s is unique, and resolves this by internally appending a unique number to next_s to make the instance unique. If you look at the generated verilog, you'll see next_s1, next_s2, next_s3, ... and so forth as it "uniquefies" the instances added to the sync attribute list.

 <nowiki>s = next_s</nowiki>

This line just stashes the reference to the Signal so the next iteration of the loop can wire up the daisy chain.

If instead of creating a new Signal() object and assigning it to next_s, but instead referencing an existing signal with the same globally unique ID, you would in fact have a whole series of Signals just wire-OR'd together. 

Here's another design pattern for doing timing delays.

 <nowiki> for i in range(rgb2ycbcr.latency + chroma_downsampler.latency):
     next_de = Signal()
     next_vsync = Signal()
     self.sync.pix += [
         next_de.eq(de),
         next_vsync.eq(vsync)
     ]
     de = next_de
     vsync = next_vsync</nowiki>

This is an in-line approach to creating the delays, reasonably compact and doesn't require templates to be defined for every signal group.

A final design pattern is to implement a synchronous buffer using a memory element to implement a delay:
 <nowiki> class _SyncBuffer(Module):
    def __init__(self, width, depth):
        self.din = Signal(width)
        self.dout = Signal(width)
        self.re = Signal()
        # # #
        produce = Signal(max=depth)
        consume = Signal(max=depth)
        storage = Memory(width, depth)
        self.specials += storage
        #
        wrport = storage.get_port(write_capable=True)
        self.specials += wrport
        self.comb += [
            wrport.adr.eq(produce),
            wrport.dat_w.eq(self.din),
            wrport.we.eq(1)
        ]
        self.sync += _inc(produce, depth)
        #
        rdport = storage.get_port(async_read=True)
        self.specials += rdport
        self.comb += [
            rdport.adr.eq(consume),
            self.dout.eq(rdport.dat_r)
        ]
        self.sync += If(self.re, _inc(consume, depth))</nowiki>
 
This uses the "storage" paradigm plus pointer arithmetic. It has the advantage that the delay can be varied dynamically (not at compile time) and can also be more efficient for long delays, since instead of eating FD's for delays it's using a block RAM. It does require some additional logic to wrap around the SyncBuffer to let it "fill" first to the depth you need for the delay before draining it.

===Module I/O===
How streams & records can be used for module I/O

===Streams===
More about how streams a can be used (asyncfifo, upconverter, downconverter, etc.)

===Records===
...yah...i don't even know this one really, but it seems important...

===Multi-Domain Clocking===
Design patterns and strategies for dealing with multiple clock domains

==Debugging==
===Litescope===
To be written: how to instantiate litescope, how to find & connect signals to litescope, how to drive litescope
===Netlist===
To be written: looking in top.v is often the fastest way to pick out subtle bugs in your Python code

==IP Cores==
Docs about the IP cores. It will take a long time to be comprehensive but initially populate with instantiation templates, explanation of options, plus inputs/outputs

==Glossary==
{|  
|----
! scope="col" width="width:20em;" |LiteX term
! scope="col" width="width:20em;" |Meaning
|-
|Gateware
|Bitstream. The stuff that goes into an FPGA
|-
|Firmware
|Loadable application code, usually dropped into DRAM
|-
|BIOS
|Bootstrapping code baked into the bitsream of the FPGA
|----
|}

